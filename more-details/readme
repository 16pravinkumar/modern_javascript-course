shortcuts for if-statements (ternary,guard and default) 

In JavaScript, there are several shortcuts for writing conditional statements using if-statements, including ternary operators, guard clauses, and default values. Here are examples of each:

1. **Ternary Operator**:
   The ternary operator is a concise way to express a simple if-else statement. It has the form: `condition ? expressionIfTrue : expressionIfFalse`. It's useful when you want to assign a value or perform a simple action based on a condition.

   Example:

   ```javascript
   // If-else statement
   if (x > 10) {
     result = "x is greater than 10";
   } else {
     result = "x is not greater than 10";
   }

   // Ternary operator equivalent
   result = x > 10 ? "x is greater than 10" : "x is not greater than 10";
   ```

2. **Guard Clauses**:
   Guard clauses are used to handle exceptional cases or edge conditions at the beginning of a function. They are particularly useful for early return from a function to avoid deeply nested if-else structures.

   Example:

   ```javascript
   // Traditional if-else structure
   function divide(a, b) {
     if (b === 0) {
       return "Division by zero is not allowed";
     } else {
       return a / b;
     }
   }

   // Guard clause
   function divide(a, b) {
     if (b === 0) {
       return "Division by zero is not allowed";
     }
     return a / b;
   }
   ```

3. **Default Values**:
   Default values can be assigned to variables or function parameters using the logical OR (`||`) operator. If the value is falsy, the default value is used.

   Example:

   ```javascript
   // Traditional default value assignment
   let name = someName || "Stranger";

   // ES6 default parameter
   function greet(name = "Stranger") {
     return "Hello, " + name + "!";
   }
   ```

These shortcuts can make your code more concise and readable, especially for simple conditional logic. However, it's important to use them judiciously, as overusing shortcuts can lead to reduced code readability in more complex scenarios.





********************************************************************************************

more information about objects 
eg 
let product = {
  name : "Pravin",
   ['age'] : 20
}

console.log(product.name) ==> o/p ==> "Pravin"
console.log(product.age) ==> o/p ==> undefined
console.log(product.delivery-date) ==> o/p ==> error becasue it things tha date is some other value it simple term it just things that we are dowing seperation between delivery and date to solve this proble we use below method i.e box notation
console.log(product.['delivery-date']) ==> o/p ==> undefined



| Feature                   | Bracket Notation                                                                                                            | Dot Notation                       |
|---------------------------|---------------------------------|-------------------------------------------------------------------------------------------|
| **Key Syntax**            | Uses strings or variables enclosed in square brackets: `object['key']`                                                      | Uses the literal key as a string without quotes: `object.key`                         |
| **Key Evaluation**        | Can dynamically evaluate keys using expressions: `object[variable]`                                                         | Requires a fixed, literal key: `object.variable`                                     |
| **Usage**                 | Useful when key is dynamic or not a valid identifier, e.g., `object['property-name']`                                       | Suitable for static keys that are valid identifiers, e.g., `object.propertyName`       |
| **Example**               | ```javascript const person = { name: 'John', age: 30 }; const key = 'name'; console.log(person[key]); // Output: 'John' ``` | ```javascript const person = { name: 'John', age: 30 }; console.log(person.name); // Output: 'John' ```  |

In summary, bracket notation allows for dynamic key evaluation using expressions and is suitable when dealing with keys that are not valid identifiers. Dot notation, on the other hand, is more concise and suitable for static keys that are valid identifiers.
